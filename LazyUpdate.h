//// Created by Ond≈ôej Merta on 04.02.2026.//#ifndef LAZYAVL_LAZYUPDATE_H#define LAZYAVL_LAZYUPDATE_H#include <functional>#include <optional>#include <algorithm>/* * LazyUpdate.h * * Implementation of a generic AVL Tree with Lazy Propagation support. * * ACADEMIC DISCLAIMER: * This code was developed as a solution for a coursework assignment at FIT CTU. * It is published here for portfolio purposes to demonstrate understanding of * complex data structures and C++ templates. * * WARNING FOR STUDENTS: * If you are currently enrolled in the same course, strictly adhere to your * university's academic integrity policies. Do not copy this code or submit * it as your own work. Plagiarism checking tools are very effective. */template < typename K, typename V, typename Op = std::plus<V> > // K - key type, V - value type, Op - aggregation operationstruct LazyUpdate {    struct Node{        K key; // The key of the node        V value; // The value associated with the key        Node *left; // Pointer to the left child        Node *right; // Pointer to the right child        Node *parent; // Pointer to the parent node        int balance; // Balance factor for AVL property (-1, 0, 1)        size_t height; // Height of the node in the tree        V pending_update = V{}; // Lazy propagation tag for pending updates    };    Node *root = nullptr;    size_t size_ = 0;    /**     * Inserts a new key and value into the tree.     * Ensures the tree remains balanced (AVL) and handles lazy propagation checks.     *     * @param key The key to insert.     * @param value The value associated with the key.     * @return true if insertion was successful, false if the key already exists.     */    bool insert(const K& key, const V& value) {        // 1. Check for existence and Push Down Lazy Updates.        // Before inserting, we check if the key exists. Crucially, applyUpdate()        // cleans the path by pushing down pending updates. This ensures that        // if we later rotate nodes on this path, they have up-to-date values.        if(applyUpdate(key) != nullptr){            return false;        }        // 2. Find the insertion point (Standard BST traversal).        // Using a double pointer (Node **) allows us to handle the 'root' case        // and standard 'child' cases uniformly without extra branching.        Node ** current = &root;        Node * parent = nullptr;        while(*current != nullptr){            if(key == (*current)->key){                return false;            }            parent = *current;            if(key < (*current)->key){                current = &(*current)->left;            }            else{                current = &(*current)->right;            }        }        // 3. Insert the new node.        *current = new Node{key, value, nullptr, nullptr, parent, 0, 1}; // New node with height 1 and balance 0        size_++; // Increment tree size        // 4. Rebalance (AVL Logic).        // Walk up from the inserted node to the root, updating heights        // and performing rotations if the AVL balance factor condition (-1, 0, 1) is violated.        Node * node = *current;        while (node != nullptr) {            recomputeHeight(node);            recomputeBalance(node);            // Perform rotations if the node is unbalanced.            if (node->balance == -2) {                if (node->left && node->left->balance == -1) {                    rightRotation(node);                } else {                    leftRotation(node->left);                    rightRotation(node);                }            } else if (node->balance == 2) {                if (node->right && node->right->balance == 1) {                    leftRotation(node);                } else {                    rightRotation(node->right);                    leftRotation(node);                }            }            node = node->parent;        }        return true;    }    /**     * Removes a node with the specified key from the tree.     * It handles standard BST deletion cases and ensures the tree remains balanced (AVL).     * Crucially, it also manages lazy propagation during the traversal.     *     * @param key The key of the node to remove.     * @return The value of the removed node, or std::nullopt if not found.     */    std::optional<V> erase(const K& key) {        // 1. Locate the node.        // applyUpdate() is used instead of a standard search because we must        // propagate any pending lazy updates down to the node before deleting it.        Node * current = applyUpdate(key);        if(current == nullptr){            return std::nullopt; //Key not found        }        Node * parent = current->parent;        std::optional<V> ret = current->value; // Save value to return later        // 2. Deletion.        // Case 1: Node has NO children (Leaf node).        // Simply remove the node and update the parent's pointer.        if(!current->left && !current->right){            Node * tmp = current;            if(parent){                if(parent->left == current){ //current is left child                    parent->left = nullptr;                }                else{                    //current is right child                    parent->right = nullptr;                }            }            else{                root = nullptr; // Tree is now empty            }            delete tmp;        }        // Case 2: Node has ONE child (Left or Right).        // Bypass the current node: link the parent directly to the child.        else if(current->left && !current->right)        {            //left child only            Node * tmp = current;            Node * child = current->left;            child->parent = parent; //update child's parent            if(parent){                if(parent->left == current){                    //current is left child                    parent->left = child;                }                else{                    //current is right child                    parent->right = child;                }            }            else{                //The removed node was the root                //Child becomes the new root                root = child;            }            delete tmp;        } else if(!current->left && current->right){            //right child only            Node * tmp = current;            Node * child = current->right;            child->parent = parent; //Update child's parent            if(parent){                if(parent->left == current){                    //current is left child                    parent->left = child;                }                else{                    //current is right child                    parent->right = child;                }            }            else{                //The removed node was the root                //Child becomes the new root                root = child;            }            delete tmp;        }        // Case 3: Node has TWO children.        // We replace the node with its in-order successor (the smallest node in the right subtree).        else{            Node * successor = current->right;            // IMPORTANT: While searching for the successor, we MUST push down lazy updates.            // If we don't, the successor might move up carrying stale data or missing updates.            while(successor->left){                pushDownUpdate(successor);                successor = successor->left;            }            pushDownUpdate(successor); // Ensure the successor itself is up-to-date            current->key = successor->key; //replace key            current->value = successor->value; //replace value            // Now remove the physical successor node.            // The successor is guaranteed to have at most one child (the right one).            parent = successor->parent;            Node * successorChild = successor->right;            if(parent->left == successor){                //successor is left child                parent->left = successorChild;            }            else{                //successor is right child                parent->right = successorChild;            }            if(successorChild){                successorChild->parent = parent;            }            delete successor;        }        size_--; // Decrement tree size        // 3. Rebalance (AVL Logic).        // Walk up from the deletion point to the root, updating heights        // and performing rotations if the AVL balance factor condition (-1, 0, 1) is violated.        Node* node = parent;        while (node != nullptr) {            recomputeHeight(node);            recomputeBalance(node);            // Perform rotations if the node is unbalanced.            if (node->balance == -2) {                if (node->left && node->left->balance <= 0) {                    rightRotation(node);                } else {                    leftRotation(node->left);                    rightRotation(node);                }            } else if (node->balance == 2) {                if (node->right && node->right->balance >= 0) {                    leftRotation(node);                } else {                    rightRotation(node->right);                    leftRotation(node);                }            }            node = node->parent;        }        return ret;    }    /**     * Retrieves the current value associated with the given key.     *     * IMPORTANT: This method is 'const', meaning it cannot modify the tree structure.     * Therefore, it cannot perform the standard "push down" of lazy updates.     * Instead, it simulates the propagation by collecting pending updates     * on the fly as it traverses from the root to the target node.     *     * @param key The key to search for.     * @return The value with all pending updates applied, or std::nullopt if not found.     */    std::optional<V> value(const K& key) const {        Node * current = root;        // Accumulator for lazy updates.        // As we descend the tree, we collect the 'pending_update' values        // from every ancestor node instead of pushing them down.        V accumulated_update = V{};        while(current != nullptr){            // Simulate pushing down the lazy update by accumulating it.            accumulated_update = Op{}(accumulated_update, current->pending_update);            if(key == current->key){                // Found the key, apply accumulated updates.                return Op{}(current->value, accumulated_update);            }            else if(key < current->key){                current = current->left;            }            else{                current = current->right;            }        }        return std::nullopt;    }    /**     * Performs a lazy range update on the interval [first, last].     * Instead of visiting every node, it decomposes the range into O(log N) subtrees.     * @param first The lower bound of the interval (inclusive).     * @param last The upper bound of the interval (inclusive).     * @param by The value to apply using the aggregation operation (Op).     */    void update(const K& first, const K& last, const V& by) {        // 1. Identify the Lowest Common Ancestor (LCA).        // This is the node where the paths to 'first' and 'last' diverge.        // The entire query range is contained within the subtree of this node.        Node * lca = lowestCommonAncestor(first, last);        if(!lca) return;        // Apply pending updates on the LCA node.        pushDownUpdate(lca);        //Update the LCA node's value.        lca->value = Op{}(lca->value, by);        // 2. Traverse the path to the lower bound ('first').        // We go down the tree looking for 'first'.        // Whenever we move left, it means the current node and its right subtree are inside the range.        Node * current = lca->left;        while(current)        {            if(current->key == first)            {                pushDownUpdate(current);                current->value = Op{}(current->value, by);                // Exact match: The node is the start of the range.                // Its entire right subtree is inside the range -> apply lazy tag.                if(current->right)                    current->right->pending_update = Op{}(current->right->pending_update, by);                break;            }            if(current->key > first)            {                // The current node is inside the range [first, last].                pushDownUpdate(current);                current->value = Op{}(current->value, by);                // Since we are moving left to find 'first', the node's RIGHT child                // is definitely fully within the range. Tag it.                if(current->right)                    current->right->pending_update = Op{}(current->right->pending_update, by);                // Move left to continue searching for 'first'.                current = current->left;            }            else            {                // The current node is to the left of 'first' (outside the range).                // Just move right to get closer to the valid interval.                current = current->right;            }        }        // 3. Traverse the path to the upper bound ('last').        // Symmetric logic to the left path.        // Whenever we move right, the current node and its left subtree are inside the range.        current = lca->right;        while(current)        {            if(current->key == last)            {                pushDownUpdate(current);                current->value = Op{}(current->value, by);                // Exact match: The node is the end of the range.                // Its entire left subtree is inside the range -> apply lazy tag.                if(current->left)                    current->left->pending_update = Op{}(current->left->pending_update, by);                break;            }            if(current->key > last)            {                // The current node is to the right of 'last' (outside the range).                // Move left to get back into bounds.                current = current->left;            }            else            {                // The current node is inside the range.                pushDownUpdate(current);                current->value = Op{}(current->value, by);                // Since we move right to find 'last', the LEFT child is fully inside. Tag it.                if(current->left)                    current->left->pending_update = Op{}(current->left->pending_update, by);                // Move right to continue searching for 'last'.                current = current->right;            }        }    }    /**     * Destructor to clean up the AVL tree and free allocated memory.     */    ~LazyUpdate(){        destroy(root);    }    // Mandatory interface required by the course's testing framework.    struct TesterInterface {        static const Node *root(const LazyUpdate *t) { return t->root; }        static const Node *parent(const Node *n) { return n->parent; }        static const Node *right(const Node *n) { return n->right; }        static const Node *left(const Node *n) { return n->left; }        static const K& key(const Node *n) { return n->key; }        static const V& value(const Node *n) { return n->value; }        static const V& pending_update(const Node *n) { return n->pending_update; }    };private:    /**     * Propagates (pushes) the pending lazy update from the current node to its children.     *     * This ensures that the current node's value is up-to-date and that the responsibility     * for the update is passed down to the next level. This must be called before     * accessing children or performing rotations to ensure data consistency.     *     * @param node The node to process.     */    void pushDownUpdate(Node * node)    {        node->value = Op{}(node->value, node->pending_update); // Apply the pending update to the current node's value.        V & by = node->pending_update; // Reference to the pending update for clarity.        if(node->left)            node->left->pending_update = Op{}(node->left->pending_update, by); // Propagate to left child.        if(node->right)            node->right->pending_update = Op{}(node->right->pending_update, by); // Propagate to right child.        node->pending_update = V{}; // Clear the pending update after pushing down.    }    /**     * Searches for a node with the given key while clearing the path of lazy updates.     *     * Unlike a standard BST search, this method modifies the tree by calling     * pushDownUpdate() on every visited node. This is crucial before operations     * like 'erase' or 'insert' to ensure we don't overwrite or lose pending updates.     *     * @param key The key to search for.     * @return Pointer to the node if found, otherwise nullptr.     */    Node * applyUpdate(const K& key)    {        Node * current = root;        while(current != nullptr){            pushDownUpdate(current); // Ensure the current node is up-to-date.            if(key == current->key){                return current;            }            else if(key < current->key){                current = current->left;            }            else{                current = current->right;            }        }        return nullptr;    }    /**     * Finds the Lowest Common Ancestor (LCA) for two keys in the BST.     *     * This is the specific node where the paths from root to 'first' and 'last' diverge.     * This node represents the root of the smallest subtree that fully covers     * the interval [first, last], serving as the starting point for range updates.     *     * @param first The lower bound of the interval.     * @param last The upper bound of the interval.     * @return The LCA node.     */    Node * lowestCommonAncestor(const K & first, const K & last)    {        Node * current = root;        while(current)        {            // Both keys are in the left subtree.            if(first < current->key && last < current->key)            {                // Move left.                current = current->left;            }            // Both keys are in the right subtree.            else if(first > current->key && last > current->key)            {                // Move right.                current = current->right;            }            else            {                // We have found the split point (LCA).                return current;            }        }        // If we exit the loop, it means the tree is empty.        return current;    }    /**     * Recomputes the height of the given node based on its children's heights.     * @param node The node to update.     */    void recomputeHeight(Node * node){        if(!node) return;        node->height = 1 + std::max((node->left) ? node->left->height : 0, (node->right) ? node->right->height : 0);    }    /**     * Recomputes the balance factor of the given node.     * @param node The node to update.     */    void recomputeBalance(Node* node){        if(!node) return;        node->balance = ((node->right) ? node->right->height : 0) - ((node->left) ? node->left->height : 0);    }    /**     * Performs a right rotation around node 'x'.     *     * Transformation:     * x            y     * / \          / \     * y   C   ->   A   x     * / \              / \     * A   B            B   C     *     * @param x The node that will move down (become the right child).     */    void rightRotation(Node * x)    {        if (!x || !x->left) return;        // 1. Identify nodes involved in the rotation.        Node* y = x->left;        Node* B = y->right;        Node* parent = x->parent;        // 2. Push down any pending updates to ensure data consistency.        pushDownUpdate(x);        pushDownUpdate(y);        // 3. Perform the rotation.        y->right = x;        x->left = B;        // 4. Update parent pointers.        y->parent = parent;        if (parent) {            if (parent->left == x) {                parent->left = y; // x was a left child            }            else{                parent->right = y; // x was a right child            }        } else {            root = y; // x was the root        }        x->parent = y; // Update x's parent to y        if(B) B->parent = x; // Update B's parent to x if B exists        // 5. Recompute heights and balance factors.        recomputeHeight(x);        recomputeHeight(y);        recomputeBalance(x);        recomputeBalance(y);    }    /**     * Performs a left rotation around node 'x'.     *     * Transformation:     * x                y     * / \              / \     * A   y     ->     x   C     *    / \          / \     *   B   C        A   B     *     * @param x The node that will move down (become the left child).     */    void leftRotation(Node * x)    {        if( !x || !x->right) return;        // 1. Identify nodes involved in the rotation.        Node * y = x->right;        Node * B = y->left;        Node * parent = x->parent;        // 2. Push down any pending updates to ensure data consistency.        pushDownUpdate(x);        pushDownUpdate(y);        // 3. Perform the rotation.        y->left = x;        x->right = B;        // 4. Update parent pointers.        y->parent = parent;        if(parent)        {            if(parent->left == x) {                parent->left = y; // x was a left child            }            else {                parent->right = y; // x was a right child            }        }        else{            root = y; // x was the root        }        x->parent = y; // Update x's parent to y        if(B) B->parent = x; // Update B's parent to x if B exists        // 5. Recompute heights and balance factors.        recomputeHeight(x);        recomputeHeight(y);        recomputeBalance(x);        recomputeBalance(y);    }    /**     * Recursively destroys the subtree rooted at the given node.     * @param node The root of the subtree to destroy.     */    void destroy(Node * node){        if(!node) return;        destroy (node->left);        destroy (node->right);        delete node;    }};#endif //LAZYAVL_LAZYUPDATE_H